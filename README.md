# T3 de segurança

![Static Badge](https://img.shields.io/badge/Language-C%23-purple)
![Static Badge](https://img.shields.io/badge/Framework-.NET%20Core-blue)
![Static Badge](https://img.shields.io/badge/.NET%20Version-6.0-lightblue)
![Static Badge](https://img.shields.io/badge/University-PUCRS-orange)
![Static Badge](https://img.shields.io/badge/Year-2023-green)


## $$\sf Para \space rodar \space o \space projeto$$

1. Baixe o [.NET SDK 6](https://dotnet.microsoft.com/en-us/download)
2. Rode o seguinte comando dentro da pasta T3Seguranca: `dotnet run`
3. Link para o repositório do projeto: [T3Segurança - F4NT0 Github](https://github.com/F4NT0/T3Seguranca)

## $$Resultados$$

- Abaixo se encontra os valores que retornaram na compilação do projeto:

<p>
<details>
<summary>Clique aqui para abrir!</summary>

* Valor primo gerado: $\color{green}302169981172443897262726089341$

* Valor de P que é o módulo: 0B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371

* Valor de G que é a base: 0A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5

* Valor de p convertido: 124325339146889384540494091085456630009856882741872806181731279018491820800119460022367403769795008250021191767583423221479185609066059226301250167164084041279837566626881119772675984258163062926954046545485368458404445166682380071370274810671501916789361956272226105723317679562001235501455748016154805420913

* Valor de g convertido: 115740200527109164239523414760926155534485715860090261532154107313946218459149402375178179458041461723723231563839316251515439564315555249353831328479173170684416728715378198172203100328308536292821245983596065287318698169565702979765910089654821728828592422299160041156491980943427556153020487552135890973413

* Valor de A gerado por (g^a mod p): 122794735847935340319503828419267772535250810811566570540229471479541454776420985117159124617939753931709810948357085194404549589901212718263296753649594183060941838183861493051116898359815473719679434164261181333183861457204832174728101685399612933108632070653600064669194275670133018913101567396984089710776

* A Em Hexadecimal para o professor: AEDD91F3789C0E0F426B44769E7FC931168B7BFC24904161DCE6CD72F603D9AC85710410EFB3E9F0818D711BC2FAC239A767B45AFD5F2E05494C0A08678A4BB049AEDA77E5626D9C832622B32439415BBF23F64AA3EB062CBF912B93E9DD0C5ED7E2C3A31149F2598359B49DD65AC0204FFB99CAEDD6D0D21663B5E8605F90B8

* Valor de B enviado pelo professor: 6C7204F6E00ACEC265BF290F04B636A042A42A4274B066EFC8D50E72A957792BF49FD43A71B426C7CF7B6F5D144ECDF28F917154DF0BABEA437011BE4BD8FB62F940AB576140CD5675F93435CA5A8BCF1B38FE7B3942E8A8D8B9B6155727C60E034F26537BD3DE31BDE997D369032C3DD115ACB03A896C945B399A44F5517D8B

* Mensagem enviada pelo professor: 508FAF6C53475545EC640D73F077839397A214E6E16754814FB6E70185A2BB01B47F893F36FA76F9343E7B005230FEB46ADC668C2719B9A0B1AB6E5BCD20F0AB23108901BD4A023DF938A5274F867538337EF9A7FB1C77087B354548088B42FE6ED770902203D0B7A4BF3F7E5F8B5793

* IV da mensagem do professor: 508FAF6C53475545EC640D73F0778393

* Mensagem após o padding: 97A214E6E16754814FB6E70185A2BB01B47F893F36FA76F9343E7B005230FEB46ADC668C2719B9A0B1AB6E5BCD20F0AB23108901BD4A023DF938A5274F867538337EF9A7FB1C77087B354548088B42FE6ED770902203D0B7A4BF3F7E5F8B5793

* Valor de p convertido: 124325339146889384540494091085456630009856882741872806181731279018491820800119460022367403769795008250021191767583423221479185609066059226301250167164084041279837566626881119772675984258163062926954046545485368458404445166682380071370274810671501916789361956272226105723317679562001235501455748016154805420913

* Valor de g convertido: 76152941392428234103027288896425699665740632931689521196718829200000442670779879954733801218848819073642494332715632301959382026932253912482309308324172622029364069077492823042510784285160610909539595239774760188212114024231236866370869643335070704745964209341533716484650105360829361260278773586418591694219

* Valor de V calculado: 118074652165732461800340787612028085649304043635779806119827894898072025174802268644456948734142984206131067731010592595660570610252589075335101680597453926215504157410226751329424556560918110800452320790971148428684425226837460214648220486087435242236689760289816127627270095724099767452783556096582704529257

* Valor de V em Hexadecimal: 0A824D5B69F6B42C2DE0901889008D4871D8E7FF5210D01AA8B72771A46B23C07D2278ED1024FA3B38945915BFDF97701679204C5956085C8E292837FC2641FE7C7FF026D6951FB12DBED2E6095B0E3E7283A2E1D28A38E536C1B523CA063748813994CD6EC82F395C19C7C39B6206517CF846527051D5072909438D56D457F69

* Valor do Hash S: 95ecf9eae4e1ce72510d28ee463f59081b51ea1489f52390a5cbe85e94d62775

* Valor da Chave em String: $\color{lightblue}95ecf9eae4e1ce72510d28ee463f5908$

* Texto descriptografado: Show Gabriel. Agora inverte esta mensagem e me envia ela de volta cifrada com a mesma senha

* Texto invertido: ahnes amsem a moc adarfic atlov ed ale aivne em e megasnem atse etrevni arogA .leirbaG wohS

* IV gerado: $\color{orange}0372FC8495E238901C4BCA931BA94CB1$

* Texto invertido criptografado: 0372fc8495e238901c4bca931ba94cb1ad8895c82c91ff83fe3609320fb749f3d1ea1756b1079be219dd8af075367b6dcc06b311769110ca85e84b0ef1272b4e14fc02455a0bf86261b769a671cd82c78f56d20b23e0e916dc4f1baf0eae4ab47318504d69a9bf1c6be9eceb8bbc01e93c0f6c0c228f38bb755e14ced5e04738

* Texto invertido criptografado sem IV: $\color{magenta}ad8895c82c91ff83fe3609320fb749f3d1ea1756b1079be219dd8af075367b6dcc06b311769110ca85e84b0ef1272b4e14fc02455a0bf86261b769a671cd82c78f56d20b23e0e916dc4f1baf0eae4ab47318504d69a9bf1c6be9eceb8bbc01e93c0f6c0c228f38bb755e14ced5e04738$

Informações entregues ao professor:

- **Mensagem invertida criptografada sem IV**: ad8895c82c91ff83fe3609320fb749f3d1ea1756b1079be219dd8af075367b6dcc06b311769110ca85e84b0ef1272b4e14fc02455a0bf86261b769a671cd82c78f56d20b23e0e916dc4f1baf0eae4ab47318504d69a9bf1c6be9eceb8bbc01e93c0f6c0c228f38bb755e14ced5e04738
- **Senha**: 95ecf9eae4e1ce72510d28ee463f5908

</details>
</p>



## $$Código$$

---

Abaixo os métodos desenvolvidos em C# do projeto separado em tópicos

---


- Métodos para gerar um valor aleatório BigInteger e verificando se ele é primo

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
// Método auxiliar: gerador de BigInteger em C#
private static BigInteger GenerateRandomBigInteger(BigInteger minValue, BigInteger maxValue, Random random)
        {
            int maxBytes = (int)Math.Ceiling(BigInteger.Log(maxValue, 256));
            byte[] bytes = new byte[maxBytes];
            random.NextBytes(bytes);
            bytes[bytes.Length - 1] &= (byte)0x7F; // verifica se o bit maior não foi setado
            BigInteger result = new BigInteger(bytes);

            return BigInteger.Remainder(result, maxValue - minValue + 1) + minValue;
        }

// Método auxiliar: verificar se o valor é primo (não melhorado, demora muito)
private static bool IsPrime(BigInteger number)
        {
           if(number < 2)
            {
                return false;
            }
           if(number == 2 || number == 3)
            {
                return true;
            }
           double value = Math.Sqrt((double )number);
           BigInteger valueTrans = (BigInteger)value;
           for(BigInteger i = 2; i <= valueTrans; i++)
            {
                if (number % i == 0)
                {
                    //Console.WriteLine("Valor não é primo");
                    return false;
                }
            }
            //Console.WriteLine("Valor é primo");
            return true;
        }

// Método principal: verifica o valor máximo e minimo do número de digitos (no nosso caso 30) e 
// utiliza os métodos acima para gerar
public static BigInteger GeneratePrime(int digits)
        {
            BigInteger minValue = (BigInteger)Math.Pow(10, digits - 1);
            BigInteger maxValue = (BigInteger)Math.Pow(10, digits) - 1;

            Random rand = new Random();
            BigInteger number = GenerateRandomBigInteger(minValue,maxValue,rand);
            while (!IsPrime(number))
            {
                number = GenerateRandomBigInteger(minValue, maxValue, rand);
            }
            return number;
        }
```

</details>
</p>

- Conversores criados para auxiliar nos ajustes dos valores

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
// Converter de BigInteger para Hexadecimal
public static string ConvertToHex(BigInteger number)
        {
            return number.ToString("X");
        }

// Converter de Byte Array para String
public static string ConvertByteToString(byte[] value)
        {
            String exit = BitConverter.ToString(value).Replace("-","");
            return exit;
        }

// Converter de String para Byte Array na hora de descriptografar
public static byte[] ConvertStringToByteArray(String value)
        {
            if (value.Length % 2 != 0)
            {
                throw new ArgumentException("Invalid hexadecimal string: Length must be even. " + value);
            }

            string cleanedText = value;

            int length = cleanedText.Length;
            byte[] bytes = new byte[length / 2];

            for (int i = 0; i < length; i+=2)
            {
                bytes[i/2] = Convert.ToByte(cleanedText.Substring(i,2),16);
            }
            return bytes;
        }

// Converter de String para Byte Array na encriptação
public static byte[] ConvertStringToByteArrayEncrypt(String value)
        {
            if (value.Length % 2 != 0)
            {
                throw new ArgumentException("Invalid hexadecimal string: Length must be even. " + value);
            }

            char[] charArray = value.ToCharArray();

            byte[] byteArray = new byte[charArray.Length];
            for (int i = 0; i < charArray.Length; i++)
            {
                byteArray[i] = (byte)charArray[i];
            }
            return byteArray;
        }

// Converter de Hexadecimal para BigInteger
public static BigInteger ConvertHexToBigInteger(string hexString)
        {
            BigInteger value = BigInteger.Parse(hexString, NumberStyles.HexNumber);
            return value;
        }

// Converter de String para BigInteger
public static BigInteger ConvertStringToBigInteger(string numberString)
        {
            BigInteger result;
            if (BigInteger.TryParse(numberString, out result))
            {
                return result;
            }
            else
            {
                // Handle parsing failure
                throw new ArgumentException("Invalid BigInteger string.");
            }
        }

// Conversor de String para Hexadecimal
public static string ConvertStringToHex(string text)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in text)
            {
                sb.Append(((int)c).ToString("X2"));
            }

            return sb.ToString();
        }

// Converter Byte Array para String
static string ByteArrayToString(byte[] bytes)
        {
            StringBuilder sb = new StringBuilder(bytes.Length * 2);
            foreach (byte b in bytes)
            {
                sb.AppendFormat("{0:x2}", b);
            }
            return sb.ToString();
        }

```

</details>
</p>

- Método para calcular o módulo ($G^a mod P$) e ($B^a mod P$)

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
public static BigInteger CalculateModulus(String g, BigInteger a, String p)
        {
            BigInteger modulus = ConvertHexToBigInteger(p);
            Console.WriteLine("\nValor de p convertido: " + modulus.ToString());
            BigInteger baseMod = ConvertHexToBigInteger(g);
            Console.WriteLine("\nValor de g convertido: " + baseMod.ToString());
            BigInteger calc = BigInteger.ModPow(baseMod, a, modulus); // base^exponent mod modulus
            return calc;
        }
```

</details>
</p>

- Método para calcular o Hash usando SHA256

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
public static byte[] CalculateSHA256(BigInteger value)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] valueBytes = value.ToByteArray();

                // Remove leading zero byte if present
                if (valueBytes.Length > 1 && valueBytes[0] == 0)
                    valueBytes = valueBytes.Skip(1).ToArray();

                // Reverse the byte order to little-endian
                Array.Reverse(valueBytes);

                byte[] hashBytes = sha256.ComputeHash(valueBytes);

                return hashBytes;
            }
        }
```

</details>
</p>

- Método de Descriptação de uma mensagem criptografada

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
public static string DecryptText(string msg_padded, string key, string iv)
        {
            byte[] ciphertext = ConvertStringToByteArray(msg_padded);
            string plaintext = "";
            byte[] ivBytes = ConvertStringToByteArray(iv);
            byte[] keyBytes = ConvertStringToByteArray(key);
            using (Aes aes = Aes.Create())
            {
                aes.Key = keyBytes;
                aes.IV = ivBytes;
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                ICryptoTransform decryptor = aes.CreateDecryptor();

                using (MemoryStream msDecrypt = new MemoryStream(ciphertext))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            plaintext = srDecrypt.ReadToEnd();
                            return plaintext;
                        }
                    }
                }

                return plaintext;
            }
        }
```

</details>
</p>

- Método para encriptografar uma mensagem normal

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
public static string EncryptText(string msg, string key)
        {
            for (;msg.Length < 108;)
            {
                msg = "00" + msg;
            }
            if (msg.Length % 2 != 0) msg = "0" + msg;
            byte[] plaintext = ConvertStringToByteArrayEncrypt(msg);
            byte[] keyBytes = ConvertStringToByteArray(key);
            using (Aes aes = Aes.Create())
            {
                aes.Key = keyBytes;
                byte[] iv = GenerateIV();
                Console.WriteLine("\nIV gerado: " + ConvertByteToString(iv));
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                ICryptoTransform encryptor = aes.CreateEncryptor();

                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(plaintext, 0, plaintext.Length);
                        cryptoStream.FlushFinalBlock();
                    }

                    byte[] encryptedBytes = memoryStream.ToArray();
                    return ByteArrayToString(iv) + ByteArrayToString(encryptedBytes);
                }
            }
        }
```

</details>
</p>

- Método para gerar um IV aleatório para enviar a mensagem ao professor

<p>
<details>
<summary>Clique aqui para abrir!</summary>

```csharp
static byte[] GenerateIV()
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateIV();
                return aes.IV;
            }
        }
```

</details>
</p>